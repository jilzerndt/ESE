# Praktikum 4.1 - AES Algorithm as FPGA Accelerator Block

## Overview

This lab demonstrates implementing AES encryption using a **hardware accelerator** in the FPGA (Field-Programmable Gate Array) fabric of the Xilinx Zynq UltraScale+ MPSoC. Unlike software implementations (P3), this uses dedicated hardware logic to perform AES encryption/decryption.

## Key Concepts

### 1. FPGA as Hardware Accelerator

**What is an FPGA?**
- **Field-Programmable Gate Array**: Reconfigurable digital logic
- Can implement custom hardware circuits
- Configured at boot time with a bitstream
- Acts as custom peripherals once configured

**Why use FPGA for AES?**
- **Much faster** than software for repetitive operations
- **Parallel processing**: Hardware can process multiple operations simultaneously
- **Dedicated resources**: No CPU cycles needed
- **Predictable performance**: No OS interruptions or context switches

### 2. Memory-Mapped I/O (MMIO)

The AES block in the FPGA is accessed like a peripheral device through **memory-mapped registers**:

```
Memory Map:
├─ 0x00000000 - DDR Memory
├─ 0x80000000 - FPGA/AXI Interface Base
│  └─ 0x80020000 - AES Block (offset 0x20000)
│     ├─ 0x08 - Control Register
│     ├─ 0x09 - Status Register
│     ├─ 0x0A - Config Register
│     ├─ 0x10-0x17 - Key Registers (KEY0-KEY7)
│     ├─ 0x20-0x23 - Block Registers (input)
│     ├─ 0x30-0x33 - Result Registers (output)
│     └─ 0x40-0x43 - IV Registers
```

### 3. Linux Memory Protection and mmap()

**Problem:** Linux prevents direct hardware access for security
- Memory Protection Unit (MPU) blocks arbitrary memory access
- User programs can't directly write to physical addresses

**Solution:** Use `mmap()` to request kernel permission
```c
// Open /dev/mem (physical memory)
int fd = open("/dev/mem", O_RDWR);

// Request mapped access to AES region
void *ptr = mmap(NULL, page_size, PROT_READ|PROT_WRITE,
                 MAP_SHARED, fd, 0x80020000);
```

**Result:**
- Kernel creates a virtual address mapping
- Your pointer points to virtual memory
- Hardware still uses physical address 0x80020000
- Kernel transparently translates your accesses

## Register Descriptions

### Control Register (0x08) - WRITE ONLY

Controls operations on the AES block:

| Bit | Name | Function |
|-----|------|----------|
| 0   | INIT | Write '1' to start key expansion |
| 1   | NEXT | Write '1' to start block processing |
| 2-31| -    | Unused (write '0') |

**Important:** This is WRITE-ONLY!
```c
// WRONG - read-modify-write doesn't work!
*reg |= 0x01;

// CORRECT - write complete value
*reg = (1 << CTRL_INIT_BIT);
```

### Status Register (0x09) - READ ONLY

Indicates current hardware state:

| Bit | Name  | Meaning |
|-----|-------|---------|
| 0   | READY | 1 = Key expansion complete, ready for encryption |
| 1   | VALID | 1 = Result is valid and can be read |

### Config Register (0x0A) - WRITE ONLY

Configures AES mode:

| Bit | Name    | Function |
|-----|---------|----------|
| 0   | ENC/DEC | 0 = Decrypt, 1 = Encrypt |
| 1   | KEYLEN  | 0 = 128-bit key, 1 = 256-bit key |

**Important:** Also WRITE-ONLY!
```c
uint32_t config = 0;
config |= (1 << CONFIG_ENCDEC_BIT);    // Encrypt
config |= (1 << CONFIG_KEYLEN_BIT);    // 256-bit
aes_reg[AES_CONFIG_REG] = config;
```

### Key Registers (0x10 - 0x17) - WRITE ONLY

Store the encryption key:
- **256-bit key**: Uses all 8 registers (KEY0-KEY7)
- **128-bit key**: Uses only 4 registers (KEY0-KEY3)
- Each register holds 32 bits (4 bytes)

```
KEY0 (0x10): bits 255-224  (highest bytes)
KEY1 (0x11): bits 223-192
KEY2 (0x12): bits 191-160
KEY3 (0x13): bits 159-128
KEY4 (0x14): bits 127-96
KEY5 (0x15): bits 95-64
KEY6 (0x16): bits 63-32
KEY7 (0x17): bits 31-0     (lowest bytes)
```

### Block Registers (0x20 - 0x23) - WRITE ONLY

Input data block (128 bits / 16 bytes):
```
BLOCK0 (0x20): bits 127-96
BLOCK1 (0x21): bits 95-64
BLOCK2 (0x22): bits 63-32
BLOCK3 (0x23): bits 31-0
```

### Result Registers (0x30 - 0x33) - READ ONLY

Output data block (128 bits / 16 bytes):
```
RES0 (0x30): bits 127-96
RES1 (0x31): bits 95-64
RES2 (0x32): bits 63-32
RES3 (0x33): bits 31-0
```

### IV Registers (0x40 - 0x43) - WRITE ONLY

Initialization Vector for CBC mode (128 bits / 16 bytes):
```
IV0 (0x40): bits 127-96
IV1 (0x41): bits 95-64
IV2 (0x42): bits 63-32
IV3 (0x43): bits 31-0
```

## Implementation Details

### Step-by-Step AES Operation Sequence

```
1. Load Key        → Write to KEY0-KEY7 registers
2. Configure       → Write to CONFIG register (enc/dec, key length)
3. Init Key Exp    → Write 0x01 to CONTROL register (INIT bit)
4. Wait Ready      → Poll STATUS register until READY bit = 1
5. Load IV         → Write to IV0-IV3 registers
6. Load Block      → Write to BLOCK0-BLOCK3 registers
7. Start Process   → Write 0x02 to CONTROL register (NEXT bit)
8. Wait Valid      → Poll STATUS register until VALID bit = 1
9. Read Result     → Read from RES0-RES3 registers
```

### Code Implementation Breakdown

#### 1. Memory Mapping (Already Provided)

```c
// Open /dev/mem to access physical memory
int m_mfd = open("/dev/mem", O_RDWR);

// Map the AES FPGA region into virtual address space
virtual_aes_base = mmap(NULL, sysconf(_SC_PAGE_SIZE),
                       PROT_READ|PROT_WRITE, MAP_SHARED,
                       m_mfd, AES_BASE_ADDR);

// Cast to 32-bit register pointer
uint32_t *aes_cbc_reg = (uint32_t *)(virtual_aes_base);
```

**Why this works:**
- `AES_BASE_ADDR = 0x80020000` is the physical address
- `mmap()` creates virtual memory mapping
- Kernel handles address translation
- Your writes go directly to FPGA hardware

#### 2. Loading the Key (Already Provided)

```c
uint32_t *key_word = (uint32_t *)(key);

for (uint32_t i = 0; i < KEY_SIZE/DATA_BUS_SIZE; i++) {
    aes_cbc_reg[AES_KEY_REG(i)] = key_word[i];
}
```

**Explanation:**
- `KEY_SIZE = 32` bytes (256 bits)
- `DATA_BUS_SIZE = 4` bytes (32 bits per register)
- Loop runs 8 times (32/4 = 8)
- Writes to registers 0x10, 0x11, ..., 0x17

#### 3. Configuration (STUDENT TASK - IMPLEMENTED)

```c
uint32_t config = 0;

// Set encryption/decryption mode
if (enc == AES_ENC) {
    config |= (1u << CONFIG_ENCDEC_BIT);    // Bit 0 = 1 for encrypt
} else {
    // Bit 0 = 0 for decrypt (already 0)
}

// Set key length to 256-bit
config |= (AES_256_BIT_KEY << CONFIG_KEYLEN_BIT);  // Bit 1 = 1

// Write to config register
aes_cbc_reg[AES_CONFIG_REG] = config;
```

**Why this way:**
- Config register is WRITE-ONLY (can't read back)
- Must build complete value before writing
- `CONFIG_ENCDEC_BIT = 0`: Bit 0 controls encrypt/decrypt
- `CONFIG_KEYLEN_BIT = 1`: Bit 1 controls key length
- `AES_256_BIT_KEY = 1`: Use 256-bit keys

#### 4. Key Expansion (STUDENT TASK - IMPLEMENTED)

```c
// Start key expansion
aes_cbc_reg[AES_CTRL_REG] = (1u << CTRL_INIT_BIT);

// Wait for key expansion to complete
while ( (aes_cbc_reg[AES_STATUS_REG] & (1u << STATUS_READY_BIT)) == 0 ) {
    // Busy wait - hardware is working
}
```

**What happens:**
- Writing to CTRL_INIT_BIT triggers hardware
- FPGA performs AES key schedule expansion
- Takes several clock cycles (very fast in hardware)
- READY bit goes high when complete
- Polling loop waits for completion

**Key Schedule:**
- AES doesn't use the key directly
- Must expand key into round keys
- 256-bit AES needs 15 rounds → 15 round keys
- Hardware does this automatically!

#### 5. Loading Block Data (STUDENT TASK - IMPLEMENTED)

```c
uint32_t *buf_word = (uint32_t *)(buf);

for (uint32_t i = 0; i < (16u / DATA_BUS_SIZE); i++) {
    aes_cbc_reg[AES_BLOCK_REG(i)] = buf_word[i];
}
```

**Explanation:**
- Block size = 16 bytes (AES always uses 128-bit blocks)
- 16 / 4 = 4 registers needed
- Writes to BLOCK0, BLOCK1, BLOCK2, BLOCK3
- Data is cast to 32-bit words for register access

#### 6. Loading Initialization Vector (STUDENT TASK - IMPLEMENTED)

```c
uint32_t *iv_word = (uint32_t *)(iv);

for (uint32_t i = 0; i < (IV_SIZE / DATA_BUS_SIZE); i++) {
    aes_cbc_reg[AES_IV_REG(i)] = iv_word[i];
}
```

**Explanation:**
- IV_SIZE = 16 bytes (128 bits for CBC mode)
- 16 / 4 = 4 registers
- Writes to IV0, IV1, IV2, IV3
- IV is XORed with plaintext in CBC mode

#### 7. Starting Block Processing (STUDENT TASK - IMPLEMENTED)

```c
// Trigger encryption/decryption
aes_cbc_reg[AES_CTRL_REG] = (1u << CTRL_NEXT_BIT);

// Wait for operation to complete
while ( (aes_cbc_reg[AES_STATUS_REG] & (1u << STATUS_VALID_BIT)) == 0 ) {
    // Busy wait - hardware is processing
}
```

**What happens:**
- Writing NEXT bit starts the AES round operations
- Hardware performs all 14 rounds (for 256-bit key)
- Each round: SubBytes, ShiftRows, MixColumns, AddRoundKey
- Takes many clock cycles but still very fast
- VALID bit signals completion

#### 8. Reading Result (STUDENT TASK - IMPLEMENTED)

```c
for (uint32_t i = 0; i < (16u / DATA_BUS_SIZE); i++) {
    buf_word[i] = aes_cbc_reg[AES_RESULT_REG(i)];
}
```

**Explanation:**
- Read all 4 result registers
- Result overwrites input buffer
- Data is encrypted/decrypted in place

### Timing Measurements (main.c)

```c
clock_gettime(CLOCK_REALTIME, &time_start);
AES_FPGA_encrypt_buffer(key, iv, enc_a, text_length);
clock_gettime(CLOCK_REALTIME, &time_stop);
```

**Measures:**
- Time for complete encryption operation
- Includes: mmap, config, key expansion, encryption, result read
- Very fast compared to software!

## Hardware vs Software AES

### Software (P3 - APU/RPU)
- **Execution:** CPU instructions, sequential
- **Speed:** Slower (depends on CPU clock, cache, etc.)
- **Flexibility:** Easy to modify algorithm
- **Power:** Uses CPU cycles continuously
- **Typical:** ~1-10 ms per operation

### Hardware (P4 - FPGA)
- **Execution:** Dedicated logic gates, parallel
- **Speed:** Much faster (hardware pipeline)
- **Flexibility:** Fixed once programmed
- **Power:** Efficient for specific tasks
- **Typical:** ~0.01-0.1 ms per operation

## Performance Advantages

**Why FPGA is faster:**

1. **Parallel Operations**
   - Software: One instruction at a time
   - FPGA: Many gates working simultaneously

2. **No Instruction Fetch/Decode**
   - Software: Fetch, decode, execute cycle
   - FPGA: Direct logic implementation

3. **Pipelined Processing**
   - Can start next block while finishing current
   - Multiple stages execute concurrently

4. **No OS Overhead**
   - Software: Interrupts, context switches
   - FPGA: Continuous operation

## Common Pitfalls

### 1. Write-Only Registers
```c
// WRONG - can't read-modify-write!
*ctrl_reg |= 0x01;

// CORRECT - write complete value
*ctrl_reg = 0x01;
```

### 2. Forgetting to Wait
```c
// Start operation
aes_cbc_reg[AES_CTRL_REG] = (1 << CTRL_NEXT_BIT);

// WRONG - read immediately (result not ready!)
result = aes_cbc_reg[AES_RESULT_REG(0)];

// CORRECT - wait for VALID bit
while (!(aes_cbc_reg[AES_STATUS_REG] & (1 << STATUS_VALID_BIT)));
result = aes_cbc_reg[AES_RESULT_REG(0)];
```

### 3. Root Permissions
```bash
# WRONG - normal user can't access /dev/mem
./fpga.elf

# CORRECT - need root for hardware access
sudo ./fpga.elf
```

### 4. Memory Alignment
```c
// Registers are 32-bit aligned
// Accessing as uint32_t* ensures proper alignment
uint32_t *aes_reg = (uint32_t *)(virtual_base);

// Not as uint8_t* which could cause alignment issues
```

## Building and Running

### Build
```bash
cd 06_P4/P4.1_AES_in_FPGA
make
make install  # Copies to Ultra96 board
```

### Run (MUST use sudo!)
```bash
ssh ese@10.0.0.1
sudo ./fpga.elf
# Password: ese
```

**Why sudo?**
- Accessing `/dev/mem` requires root privileges
- FPGA registers are physical memory addresses
- Linux security prevents normal users from direct hardware access

## Expected Output

```
Testing AES256

Input:  6162636465666768696a6b6c6d6e6f00
Output: 25972ebbc121fec478d25e7de8c8f91d
Soll:   25972ebbc121fec478d25e7de8c8f91d
AES encrypt: SUCCESS!

Input:  25972ebbc121fec478d25e7de8c8f91d
Output: 6162636465666768696a6b6c6d6e6f00
Soll:   6162636465666768696a6b6c6d6e6f00
AES decrypt: SUCCESS!

Measurement for setup, encryption, setup, decryption; Message size 16 Bytes
Time: 0.XXX ms
```

## Extended Challenge (Optional)

### Processing Multiple Blocks

Current implementation: Only handles 16-byte messages

**Challenge:** Modify to handle longer messages (64, 240 bytes)

```c
// Pseudocode for multi-block processing
for (each 16-byte block) {
    if (first_block) {
        // Use IV for first block
        load_iv(iv);
    } else {
        // Use previous ciphertext as IV (CBC mode)
        load_iv(previous_ciphertext);
    }

    load_block(current_block);
    start_processing();
    wait_for_valid();
    read_result();

    previous_ciphertext = result;
}
```

**Key considerations:**
- Only do key expansion once (before loop)
- IV for block N is ciphertext from block N-1
- This is how CBC mode works!

## Study Questions

1. **What method is used to request access to the memory region?**
   - Answer: `mmap()` - Memory Mapping

2. **Why can't we use read-modify-write on control/config registers?**
   - Answer: They are WRITE-ONLY registers. Reading returns undefined values.

3. **What happens during key expansion?**
   - Answer: The AES key schedule is computed, generating round keys for all encryption rounds.

4. **Why is FPGA AES faster than software?**
   - Answer: Dedicated parallel hardware, no instruction fetch/decode, pipelined operations, no OS overhead.

5. **What are the two status bits and what do they indicate?**
   - Answer:
     - READY (bit 0): Key expansion complete
     - VALID (bit 1): Result is ready to read

## Key Takeaways

1. **FPGA accelerators** provide massive speedup for repetitive operations
2. **Memory-mapped I/O** allows software to control hardware peripherals
3. **mmap()** provides safe hardware access in Linux
4. **Write-only registers** require writing complete values, not read-modify-write
5. **Polling status bits** ensures hardware operations complete before reading results
6. **Hardware acceleration** trades flexibility for speed and efficiency
7. **Root privileges** are needed for direct hardware access

## References

- [Xilinx Zynq UltraScale+ Documentation](https://www.xilinx.com/products/silicon-devices/soc/zynq-ultrascale-mpsoc.html)
- [mmap() man page](https://man7.org/linux/man-pages/man2/mmap.2.html)
- [AES Algorithm Specification](https://csrc.nist.gov/publications/detail/fips/197/final)
- [Memory-Mapped I/O](https://en.wikipedia.org/wiki/Memory-mapped_I/O)


Changes Made                                                                                                                                                                                                                                                              
                                                                                                                                                                                                                                                                            
  1. AES FPGA Driver (06_P4/P4.1_AES_in_FPGA/src/aes_fpga.c)                                                                                                                                                                                                                
                                                                                                                                                                                                                                                                            
  Implemented the complete AES hardware control sequence:                                                                                                                                                                                                                   
                                                                                                                                                                                                                                                                            
  Configuration Register Setup:                                                                                                                                                                                                                                             
                                                                                                                                                                                                                                                                            
  uint32_t config = 0;                                                                                                                                                                                                                                                      
  if (enc == AES_ENC) {                                                                                                                                                                                                                                                     
      config |= (1u << CONFIG_ENCDEC_BIT);    // Set encrypt mode                                                                                                                                                                                                           
  }                                                                                                                                                                                                                                                                         
  config |= (AES_256_BIT_KEY << CONFIG_KEYLEN_BIT);  // 256-bit key                                                                                                                                                                                                         
  aes_cbc_reg[AES_CONFIG_REG] = config;                                                                                                                                                                                                                                     
                                                                                                                                                                                                                                                                            
  Key Expansion Initialization:                                                                                                                                                                                                                                             
                                                                                                                                                                                                                                                                            
  aes_cbc_reg[AES_CTRL_REG] = (1u << CTRL_INIT_BIT);  // Start key expansion                                                                                                                                                                                                
                                                                                                                                                                                                                                                                            
  // Wait for hardware to finish                                                                                                                                                                                                                                            
  while ((aes_cbc_reg[AES_STATUS_REG] & (1u << STATUS_READY_BIT)) == 0);                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                            
  Loading Data Blocks:                                                                                                                                                                                                                                                      
                                                                                                                                                                                                                                                                            
  // Write plaintext to block registers                                                                                                                                                                                                                                     
  for (uint32_t i = 0; i < (16u / DATA_BUS_SIZE); i++) {                                                                                                                                                                                                                    
      aes_cbc_reg[AES_BLOCK_REG(i)] = buf_word[i];                                                                                                                                                                                                                          
  }                                                                                                                                                                                                                                                                         
                                                                                                                                                                                                                                                                            
  // Write IV to IV registers                                                                                                                                                                                                                                               
  for (uint32_t i = 0; i < (IV_SIZE / DATA_BUS_SIZE); i++) {                                                                                                                                                                                                                
      aes_cbc_reg[AES_IV_REG(i)] = iv_word[i];                                                                                                                                                                                                                              
  }                                                                                                                                                                                                                                                                         
                                                                                                                                                                                                                                                                            
  Block Processing:                                                                                                                                                                                                                                                         
                                                                                                                                                                                                                                                                            
  aes_cbc_reg[AES_CTRL_REG] = (1u << CTRL_NEXT_BIT);  // Start encryption                                                                                                                                                                                                   
                                                                                                                                                                                                                                                                            
  // Wait for result                                                                                                                                                                                                                                                        
  while ((aes_cbc_reg[AES_STATUS_REG] & (1u << STATUS_VALID_BIT)) == 0);                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                            
  // Read encrypted result                                                                                                                                                                                                                                                  
  for (uint32_t i = 0; i < (16u / DATA_BUS_SIZE); i++) {                                                                                                                                                                                                                    
      buf_word[i] = aes_cbc_reg[AES_RESULT_REG(i)];                                                                                                                                                                                                                         
  }                                                                                                                                                                                                                                                                         
                                                                                                                                                                                                                                                                            
  2. Main Program (main.c)                                                                                                                                                                                                                                                  
                                                                                                                                                                                                                                                                            
  Added timing measurements:                                                                                                                                                                                                                                                
  clock_gettime(CLOCK_REALTIME, &time_start);                                                                                                                                                                                                                               
  AES_FPGA_encrypt_buffer(key, iv, enc_a, text_length);                                                                                                                                                                                                                     
  clock_gettime(CLOCK_REALTIME, &time_stop);                                                                                                                                                                                                                                
                                                                                                                                                                                                                                                                            
  Documentation Created                                                                                                                                                                                                                                                     
                                                                                                                                                                                                                                                                            
  Created P4.1_Explanation.md with comprehensive coverage:                                                                                                                                                                                                                  
                                                                                                                                                                                                                                                                            
  Key Topics Covered:                                                                                                                                                                                                                                                       
                                                                                                                                                                                                                                                                            
  1. FPGA Accelerator Concepts                                                                                                                                                                                                                                              
    - What FPGAs are and why they're fast                                                                                                                                                                                                                                   
    - Hardware vs software comparison                                                                                                                                                                                                                                       
    - Parallel processing advantages                                                                                                                                                                                                                                        
  2. Memory-Mapped I/O                                                                                                                                                                                                                                                      
    - How peripherals are accessed in embedded systems                                                                                                                                                                                                                      
    - Linux memory protection and why we need mmap()                                                                                                                                                                                                                        
    - Virtual vs physical addresses                                                                                                                                                                                                                                         
  3. Complete Register Map                                                                                                                                                                                                                                                  
    - Control Register (0x08): INIT and NEXT bits                                                                                                                                                                                                                           
    - Status Register (0x09): READY and VALID bits                                                                                                                                                                                                                          
    - Config Register (0x0A): Encrypt/Decrypt, Key Length                                                                                                                                                                                                                   
    - Key Registers (0x10-0x17): 256-bit key storage                                                                                                                                                                                                                        
    - Block, Result, and IV registers                                                                                                                                                                                                                                       
  4. Step-by-Step Operation Sequence                                                                                                                                                                                                                                        
    - 9 detailed steps from key loading to result reading                                                                                                                                                                                                                   
    - Explanation of each operation                                                                                                                                                                                                                                         
    - Why each step is necessary                                                                                                                                                                                                                                            
  5. Code Implementation Details                                                                                                                                                                                                                                            
    - Line-by-line explanation of each implementation                                                                                                                                                                                                                       
    - Why registers are WRITE-ONLY or READ-ONLY                                                                                                                                                                                                                             
    - Proper handling of hardware timing                                                                                                                                                                                                                                    
  6. Performance Analysis                                                                                                                                                                                                                                                   
    - Why FPGA is 10-100x faster than software                                                                                                                                                                                                                              
    - Parallel operations and pipelining                                                                                                                                                                                                                                    
    - No OS overhead                                                                                                                                                                                                                                                        
  7. Common Pitfalls                                                                                                                                                                                                                                                        
    - Write-only register mistakes                                                                                                                                                                                                                                          
    - Forgetting to wait for status bits                                                                                                                                                                                                                                    
    - Root permission requirements                                                                                                                                                                                                                                          
    - Memory alignment issues                                                                                                                                                                                                                                               
                                                                                                                                                                                                                                                                            
  Key Concepts Explained                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                            
  1. Memory-Mapped Registers                                                                                                                                                                                                                                                
                                                                                                                                                                                                                                                                            
  The FPGA AES block appears at physical address 0x80020000. We use mmap() to safely access it from user space.                                                                                                                                                             
                                                                                                                                                                                                                                                                            
  2. Hardware Control Flow                                                                                                                                                                                                                                                  
                                                                                                                                                                                                                                                                            
  Load Key → Configure → Init Key Expansion → Wait Ready →                                                                                                                                                                                                                  
  Load IV → Load Block → Start Processing → Wait Valid → Read Result                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                            
  3. Write-Only vs Read-Only                                                                                                                                                                                                                                                
                                                                                                                                                                                                                                                                            
  - Write-Only: Control, Config, Key, Block, IV registers                                                                                                                                                                                                                   
  - Read-Only: Status, Result registers                                                                                                                                                                                                                                     
  - Can't use |= on write-only registers!                                                                                                                                                                                                                                   
                                                                                                                                                                                                                                                                            
  4. Polling Status Bits                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                            
  Hardware operations take time. Must poll STATUS register to know when done:                                                                                                                                                                                               
  - READY bit: Key expansion complete                                                                                                                                                                                                                                       
  - VALID bit: Result available                                                                                                                                                                                                                                             
                                                                                                                                                                                                                                                                            
  Building and Running                                                                                                                                                                                                                                                      
                                                                                                                                                                                                                                                                            
  # Build                                                                                                                                                                                                                                                                   
  cd 06_P4/P4.1_AES_in_FPGA                                                                                                                                                                                                                                                 
  make                                                                                                                                                                                                                                                                      
  make install                                                                                                                                                                                                                                                              
                                                                                                                                                                                                                                                                            
  # Run (REQUIRES sudo!)                                                                                                                                                                                                                                                    
  ssh ese@10.0.0.1                                                                                                                                                                                                                                                          
  sudo ./fpga.elf                                                                                                                                                                                                                                                           
                                                                                                                                                                                                                                                                            
  Important: Must use sudo because accessing /dev/mem (physical memory) requires root privileges!                                                                                                                                                                           
                                                                                                                                                                                                                                                                            
  Expected Performance                                                                                                                                                                                                                                                      
                                                                                                                                                                                                                                                                            
  The FPGA implementation should be much faster than software:                                                                                                                                                                                                              
  - Software (P3): ~1-10 ms                                                                                                                                                                                                                                                 
  - FPGA (P4.1): ~0.01-0.1 ms (10-100x speedup!)                                                                                                                                                                                                                            
                                                                                                                                                                                                                                                                            
  This speed comes from:                                                                                                                                                                                                                                                    
  - Dedicated parallel hardware logic                                                                                                                                                                                                                                       
  - No instruction fetch/decode overhead                                                                                                                                                                                                                                    
  - Pipelined operations                                                                                                                                                                                                                                                    
  - No operating system interruptions                                                                                                                                                                                                                                       
                                                                                                                                                                                                                                                                            
  The solution is complete and ready to test on the Ultra96 board!  