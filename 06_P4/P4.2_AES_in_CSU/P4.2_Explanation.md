# Praktikum 4.2 - AES in the Configuration Security Unit (CSU)

## Overview

This lab demonstrates using the **Configuration Security Unit (CSU)** in the Xilinx Zynq UltraScale+ MPSoC for hardware-accelerated AES encryption. Unlike P4.1 (FPGA), this uses a dedicated security processor with its own protected memory and cryptographic hardware blocks.

## Key Concepts

### 1. Configuration Security Unit (CSU)

The **CSU** is a specialized security subsystem designed to protect firmware and cryptographic operations:

```
┌─────────────────────────────────────────┐
│  Configuration Security Unit (CSU)      │
├──────────────────┬──────────────────────┤
│ Secure Processor │ Crypto Interface     │
│ Block (SPB)      │ Block (CIB)          │
├──────────────────┼──────────────────────┤
│ - Triple         │ - AES Engine         │
│   Redundant CPU  │ - SHA Engine         │
│ - Protected RAM  │ - RSA Engine         │
│ - Protected ROM  │ - Protected Key      │
│                  │   Storage (eFUSE)    │
└──────────────────┴──────────────────────┘
```

**Key Features:**

1. **Secure Processor Block (SPB):**
   - Triple-redundant processor for fault tolerance
   - Protected memory (RAM and ROM)
   - Runs independently from main CPU
   - Available from boot time

2. **Crypto Interface Block (CIB):**
   - Dedicated hardware for AES, SHA, RSA
   - Protected key storage (eFUSE)
   - Can only be written a few times
   - Once exhausted, device can't be used for security

**Why CSU is Special:**
- Available during secure boot process
- Can verify bootloader signatures
- Can decrypt encrypted firmware
- Protects private keys in hardware
- Isolated from main system for security

### 2. Socket Communication

Unlike direct register access (P4.1 FPGA), the CSU is accessed through a **socket interface** for security:

**Why Sockets?**
- CSU registers are **not publicly documented** (security through obscurity)
- Prevents direct hardware manipulation
- OS provides controlled access through kernel crypto API
- Standard Linux interface for cryptographic operations

**What is a Socket?**
A communication endpoint that abstracts low-level details:

```
┌─────────────────────┐
│  User Application   │
│  (Your Program)     │
└──────────┬──────────┘
           │ Socket API (AF_ALG)
           │
┌──────────▼──────────┐
│  Linux Kernel       │
│  Crypto API         │
└──────────┬──────────┘
           │
┌──────────▼──────────┐
│  CSU Driver         │
└──────────┬──────────┘
           │
┌──────────▼──────────┐
│  CSU Hardware       │
│  (AES/SHA/RSA)      │
└─────────────────────┘
```

### 3. Linux AF_ALG Socket API

**AF_ALG** = Address Family for ALGorithms

This is a special socket type specifically for cryptographic operations:
- **AF_INET**: Network sockets (TCP/IP)
- **AF_UNIX**: Local IPC sockets
- **AF_ALG**: Cryptographic algorithm sockets

## Socket Setup and Communication

### Complete Socket Workflow

```
1. Create Socket     → socket(AF_ALG, ...)
2. Configure Socket  → struct sockaddr_alg
3. Bind Algorithm    → bind()
4. Set Key          → setsockopt()
5. Accept Connection → accept()
6. Send Data        → sendmsg()
7. Receive Result   → read()
8. Close Socket     → close()
```

Let's examine each step in detail:

### Step 1: Create Socket

```c
int sd = socket(AF_ALG, SOCK_SEQPACKET, 0);
```

**Parameters:**
- `AF_ALG`: Address family for algorithm sockets
- `SOCK_SEQPACKET`: Sequenced, reliable, connection-based
- `0`: Protocol (auto-select)

**Returns:**
- Socket descriptor `sd` (like a file handle)
- `-1` on error

**What happens:**
- Kernel allocates socket data structure
- Prepares for crypto algorithm binding

### Step 2: Configure Algorithm Selection

```c
struct sockaddr_alg sa = {
    .salg_family = AF_ALG,           // Must be AF_ALG
    .salg_type   = "skcipher",       // Symmetric key cipher
    .salg_name   = "cbc(aes)"        // AES in CBC mode
};
```

**Structure Members:**
- `salg_family`: Always `AF_ALG` for crypto sockets
- `salg_type`: Type of algorithm
  - `"skcipher"` = Symmetric Key Cipher
  - `"hash"` = Hash algorithms (SHA, MD5)
  - `"aead"` = Authenticated Encryption with Associated Data
- `salg_name`: Specific algorithm and mode
  - `"cbc(aes)"` = AES in CBC mode
  - `"ecb(aes)"` = AES in ECB mode
  - `"ctr(aes)"` = AES in CTR mode

**Why "skcipher"?**
- Stands for "symmetric key cipher"
- AES uses the same key for encryption and decryption
- Contrasts with asymmetric algorithms (RSA)

### Step 3: Bind Socket to Algorithm

```c
ret = bind(sd, (struct sockaddr *) &sa, sizeof(sa));
```

**Parameters:**
- `sd`: Socket descriptor from step 1
- `&sa`: Address structure with algorithm config
- `sizeof(sa)`: Size of structure

**What happens:**
- Kernel binds socket to AES-CBC algorithm
- Prepares crypto engine in CSU
- Validates algorithm is available

**Error Checking:**
```c
if (ret == -1) {
    printf("bind failed: %s\n", strerror(errno));
    close(sd);
    return;
}
```

### Step 4: Set Encryption Key

```c
ret = setsockopt(sd, SOL_ALG, ALG_SET_KEY, key, AES_KEY_LENGTH);
```

**Parameters:**
- `sd`: Socket descriptor
- `SOL_ALG`: Socket option level (Algorithm)
- `ALG_SET_KEY`: Option to set encryption key
- `key`: Pointer to key data
- `AES_KEY_LENGTH`: Key size (32 bytes for AES-256)

**What happens:**
- Key is transferred to CSU
- CSU performs key expansion in hardware
- Key stored in protected memory

**Important:**
- Key length must match algorithm (16, 24, or 32 bytes)
- This implementation uses 256-bit (32 bytes)
- Key stays in CSU protected memory

### Step 5: Accept Connection

```c
fd = accept(sd, NULL, 0);
```

**Parameters:**
- `sd`: Socket descriptor
- `NULL`: Not using peer address
- `0`: No address length

**Returns:**
- File descriptor `fd` for data transfer
- Different from socket descriptor `sd`!

**What happens:**
- Creates actual data channel
- `sd` is for configuration
- `fd` is for sending/receiving data
- Like accepting a network connection

**After accept:**
```c
close(sd);  // Configuration socket no longer needed
```

### Step 6: Prepare Message with Headers

This is the most complex part! We need to send:
1. **Control message headers** (encrypt/decrypt, IV)
2. **Actual data** (plaintext/ciphertext)

```c
struct msghdr msg = {};
char cbuf[CMSG_SPACE(4) + CMSG_SPACE(20)] = {0};
msg.msg_control = cbuf;
msg.msg_controllen = sizeof(cbuf);
```

**msghdr Structure:**
- Contains both control information and data
- `msg_control`: Ancillary data (headers)
- `msg_iov`: Actual data buffer
- `msg_iovlen`: Number of data buffers

#### First Header: Operation Type

```c
struct cmsghdr *cmsg = CMSG_FIRSTHDR(&msg);
cmsg->cmsg_level = SOL_ALG;
cmsg->cmsg_type = ALG_SET_OP;
cmsg->cmsg_len = CMSG_LEN(4);
*(__u32 *)CMSG_DATA(cmsg) = enc_dir;  // ALG_OP_ENCRYPT or ALG_OP_DECRYPT
```

**Purpose:** Tell CSU whether to encrypt or decrypt

**Structure:**
- `cmsg_level`: `SOL_ALG` (algorithm layer)
- `cmsg_type`: `ALG_SET_OP` (set operation)
- `cmsg_len`: Length of data (4 bytes for uint32)
- `CMSG_DATA(cmsg)`: Actual operation value

#### Second Header: Initialization Vector

```c
cmsg = CMSG_NXTHDR(&msg, cmsg);  // Move to next header
cmsg->cmsg_level = SOL_ALG;
cmsg->cmsg_type = ALG_SET_IV;
cmsg->cmsg_len = CMSG_LEN(20);

struct af_alg_iv *ivp = (void *)CMSG_DATA(cmsg);
ivp->ivlen = 16;              // IV is 16 bytes for AES
memcpy(ivp->iv, iv, 16);      // Copy IV data
```

**Purpose:** Set initialization vector for CBC mode

**af_alg_iv Structure:**
```c
struct af_alg_iv {
    __u32 ivlen;     // Length of IV (16 for AES)
    __u8 iv[0];      // Flexible array for IV data
};
```

#### Data Buffer

```c
struct iovec iov = {buf, length};
msg.msg_iov = &iov;
msg.msg_iovlen = 1;
```

**iovec Structure:**
- Contains actual plaintext/ciphertext
- `iov_base`: Pointer to data buffer
- `iov_len`: Length of data

**Complete Message Structure:**
```
┌─────────────────┐
│  msghdr         │
├─────────────────┤
│ msg_control ────┼──┐
│ msg_iov ────────┼──│───┐
└─────────────────┘  │   │
                     │   │
    ┌────────────────┘   │
    │                    │
    ▼                    ▼
┌─────────────────┐  ┌───────────────┐
│ Control Headers │  │  Data Buffer  │
├─────────────────┤  │               │
│ 1. Operation    │  │  Plaintext or │
│    (Enc/Dec)    │  │  Ciphertext   │
├─────────────────┤  │               │
│ 2. IV           │  │               │
│    (16 bytes)   │  │               │
└─────────────────┘  └───────────────┘
```

### Step 7: Send Message

```c
ret = sendmsg(fd, &msg, 0);
```

**Parameters:**
- `fd`: File descriptor from accept()
- `&msg`: Message structure with headers and data
- `0`: No special flags

**What happens:**
- Entire message sent to kernel
- Kernel forwards to CSU driver
- CSU hardware performs encryption/decryption
- Result buffered in kernel

**Error Checking:**
```c
if (ret == -1) {
    printf("sendmsg failed: %s\n", strerror(errno));
    close(fd);
    return;
}
```

### Step 8: Receive Result

```c
ret = read(fd, buf, length);
```

**Parameters:**
- `fd`: File descriptor
- `buf`: Buffer for result (same buffer as input!)
- `length`: Expected result length

**What happens:**
- Reads encrypted/decrypted result
- Overwrites input buffer with result
- Blocking call (waits for CSU to finish)

**Important:**
- Result goes back into the same buffer
- In-place encryption/decryption
- No separate output buffer needed

### Step 9: Cleanup

```c
close(fd);
```

**What happens:**
- Releases data channel
- Frees CSU resources
- Socket can be reused by creating new `fd` via accept()

## Complete Message Flow Diagram

```
Your Program          Linux Kernel         CSU Hardware
     │                     │                     │
     │ socket(AF_ALG)      │                     │
     ├────────────────────>│                     │
     │ <──────────────────┤                     │
     │        sd           │                     │
     │                     │                     │
     │ bind(sa)            │                     │
     ├────────────────────>│                     │
     │                     │ Configure AES-CBC   │
     │                     ├────────────────────>│
     │ <──────────────────┤                     │
     │                     │                     │
     │ setsockopt(key)     │                     │
     ├────────────────────>│                     │
     │                     │ Load Key            │
     │                     ├────────────────────>│
     │                     │ Key Expansion       │
     │                     │<────────────────────┤
     │ <──────────────────┤                     │
     │                     │                     │
     │ accept()            │                     │
     ├────────────────────>│                     │
     │ <──────────────────┤                     │
     │        fd           │                     │
     │                     │                     │
     │ sendmsg(data+IV)    │                     │
     ├────────────────────>│                     │
     │                     │ Encrypt/Decrypt     │
     │                     ├────────────────────>│
     │                     │   Processing...     │
     │                     │<────────────────────┤
     │                     │   Result            │
     │ read()              │                     │
     ├────────────────────>│                     │
     │ <──────────────────┤                     │
     │    Result Data      │                     │
     │                     │                     │
     │ close(fd)           │                     │
     ├────────────────────>│                     │
     │                     │ Release Resources   │
     │                     ├────────────────────>│
     │                     │                     │
```

## Implementation Details

### Complete Code Flow

```c
static void AES_CSU_xcrypt_buffer(int enc_dir, const uint8_t* key,
                                   const uint8_t* iv, uint8_t* buf,
                                   size_t length)
{
    // 1. Create socket
    int sd = socket(AF_ALG, SOCK_SEQPACKET, 0);

    // 2. Configure algorithm
    struct sockaddr_alg sa = {
        .salg_family = AF_ALG,
        .salg_type   = "skcipher",
        .salg_name   = "cbc(aes)"
    };

    // 3. Bind to algorithm
    bind(sd, (struct sockaddr *) &sa, sizeof(sa));

    // 4. Set encryption key
    setsockopt(sd, SOL_ALG, ALG_SET_KEY, key, AES_KEY_LENGTH);

    // 5. Get data channel
    int fd = accept(sd, NULL, 0);
    close(sd);  // Don't need config socket anymore

    // 6. Prepare message headers
    struct msghdr msg = {};
    char cbuf[CMSG_SPACE(4) + CMSG_SPACE(20)] = {0};
    msg.msg_control = cbuf;
    msg.msg_controllen = sizeof(cbuf);

    // Set operation (encrypt/decrypt)
    struct cmsghdr *cmsg = CMSG_FIRSTHDR(&msg);
    cmsg->cmsg_level = SOL_ALG;
    cmsg->cmsg_type = ALG_SET_OP;
    cmsg->cmsg_len = CMSG_LEN(4);
    *(__u32 *)CMSG_DATA(cmsg) = enc_dir;

    // Set IV
    cmsg = CMSG_NXTHDR(&msg, cmsg);
    cmsg->cmsg_level = SOL_ALG;
    cmsg->cmsg_type = ALG_SET_IV;
    cmsg->cmsg_len = CMSG_LEN(20);
    struct af_alg_iv *ivp = (void *)CMSG_DATA(cmsg);
    ivp->ivlen = 16;
    memcpy(ivp->iv, iv, 16);

    // Set data buffer
    struct iovec iov = {buf, length};
    msg.msg_iov = &iov;
    msg.msg_iovlen = 1;

    // 7. Send for processing
    sendmsg(fd, &msg, 0);

    // 8. Read result
    read(fd, buf, length);

    // 9. Cleanup
    close(fd);
}
```

## CSU vs FPGA vs Software Comparison

### Performance Characteristics

| Aspect | Software (P3) | FPGA (P4.1) | CSU (P4.2) |
|--------|---------------|-------------|------------|
| **Speed** | Slow (~1-10ms) | Very Fast (~0.01-0.1ms) | Fast (~0.1-1ms) |
| **Security** | None | Low | **Very High** |
| **Key Storage** | RAM (unprotected) | Registers (visible) | eFUSE (protected) |
| **Setup Cost** | Low | Low (mmap) | Medium (socket setup) |
| **Isolation** | None | None | **Fully Isolated** |
| **Boot-time** | No | No | **Yes** |

### Why CSU is Slower Than FPGA

Even though both are hardware:

1. **Socket Overhead:**
   - FPGA: Direct register write
   - CSU: Socket → Kernel → Driver → CSU

2. **Message Passing:**
   - FPGA: Direct memory access
   - CSU: Copy data through kernel

3. **Security Overhead:**
   - FPGA: No checks
   - CSU: Validation and protection

**But CSU provides:**
- Protected key storage (can't be read back)
- Isolated execution environment
- Secure boot capabilities
- Tamper resistance

## Timing Measurements

### Main Program Timing

```c
clock_gettime(CLOCK_REALTIME, &time_start);
AES_CSU_encrypt_buffer(key, iv, enc_a, text_length);
clock_gettime(CLOCK_REALTIME, &time_stop);
```

**What this measures:**
- Socket creation
- Binding and configuration
- Key setting
- Message preparation
- Encryption
- Result retrieval

**Note:** Each call creates a new socket!
- Socket overhead included in every call
- Unlike FPGA where setup is once

### Optimization Opportunity

For multiple operations, could:
1. Create socket once
2. Keep `fd` open
3. Reuse for multiple `sendmsg`/`read` cycles
4. Close at end

This would reduce overhead significantly!

## Security Features

### 1. Protected Key Storage (eFUSE)

```
┌─────────────────────────────────┐
│  eFUSE Key Storage              │
├─────────────────────────────────┤
│  - One-time programmable        │
│  - Limited write cycles (≈10)   │
│  - Cannot be read back          │
│  - Physically protected         │
│  - Survives power off           │
└─────────────────────────────────┘
```

**Use case:** Store device-unique encryption keys

### 2. Secure Boot

CSU can:
1. Verify bootloader signature (RSA)
2. Decrypt bootloader (AES)
3. Ensure only authentic code runs

### 3. Memory Protection

- CSU memory isolated from main system
- Triple-redundant processor detects tampering
- Keys never exposed to main CPU

## Common Issues

### 1. Socket Creation Fails
```
Error: socket failed: Operation not permitted
```
**Solution:** Run with sudo or as root

### 2. Algorithm Not Available
```
Error: bind failed: No such file or directory
```
**Cause:** Crypto algorithm not compiled into kernel
**Solution:** Check `/proc/crypto` for available algorithms

### 3. Wrong Key Length
```
Error: setsockopt failed: Invalid argument
```
**Cause:** Key length doesn't match algorithm
**Solution:** Use 32 bytes for AES-256, 16 for AES-128

### 4. Data Not Multiple of 16
```
Error: sendmsg failed: Invalid argument
```
**Cause:** AES requires 16-byte blocks
**Solution:** Ensure data length is multiple of 16

## Testing Different Message Sizes

The code includes test vectors for:
- **16 bytes** (1 block)
- **64 bytes** (4 blocks)
- **240 bytes** (15 blocks)

Uncomment different sections in main.c to test:

```c
// Small (16 bytes)
uint8_t enc_a[] = { 0x61, 0x62, ... };

// Medium (64 bytes) - uncomment this
// uint8_t enc_a[] = { 0x6b, 0xc1, ... };

// Large (240 bytes) - or uncomment this
// uint8_t enc_a[240] = { 0 };
```

Expected performance scaling:
- Larger messages → better throughput
- Socket overhead amortized over more data
- CSU can process multiple blocks efficiently

## Build and Run

### Building
```bash
cd 06_P4/P4.2_AES_in_CSU
make
make install  # Copies to Ultra96
```

### Running
```bash
ssh ese@10.0.0.1
./csu.elf
```

**Note:** No sudo needed (unlike FPGA)!
- Socket API doesn't require root
- Kernel handles permissions

## Expected Output

```
Testing AES256

Input:  6162636465666768696a6b6c6d6e6f00
Output: 25972ebbc121fec478d25e7de8c8f91d
Soll:   25972ebbc121fec478d25e7de8c8f91d
AES encrypt: SUCCESS!

Input:  25972ebbc121fec478d25e7de8c8f91d
Output: 6162636465666768696a6b6c6d6e6f00
Soll:   6162636465666768696a6b6c6d6e6f00
AES decrypt: SUCCESS!

Measurement for encryption; Message size 16 Bytes
Time: X.XXX ms
```

## Key Takeaways

1. **CSU provides hardware security** not just hardware acceleration
2. **Socket API abstracts complexity** and provides security isolation
3. **AF_ALG sockets** are Linux's standard crypto interface
4. **Message structure** is complex but flexible for various crypto needs
5. **Protected key storage** makes CSU ideal for production devices
6. **Secure boot capability** ensures firmware authenticity
7. **Trade-off:** Slower than FPGA but much more secure

## Study Questions

1. **What are the two main parts of the CSU?**
   - Secure Processor Block (SPB) - triple-redundant CPU with protected memory
   - Crypto Interface Block (CIB) - hardware crypto engines (AES, SHA, RSA)

2. **Why use sockets instead of direct register access?**
   - CSU registers not publicly documented for security
   - Prevents direct hardware manipulation
   - Kernel provides controlled, validated access

3. **What does AF_ALG stand for?**
   - Address Family for ALGorithms
   - Socket type for cryptographic operations

4. **What information is in the message headers?**
   - Operation type (encrypt/decrypt)
   - Initialization Vector (IV)

5. **Why is the CSU slower than FPGA but still valuable?**
   - Socket and kernel overhead
   - But provides: protected key storage, secure boot, isolation, tamper resistance

6. **What is eFUSE and why is it important?**
   - One-time programmable memory for keys
   - Limited write cycles
   - Cannot be read back
   - Physically protected against tampering

## References

- [Xilinx UG1137: Zynq UltraScale+ Software Developer Guide](https://www.xilinx.com/support/documentation/user_guides/ug1137-zynq-ultrascale-mpsoc-swdev.pdf)
- [Linux Crypto API](https://www.kernel.org/doc/html/latest/crypto/index.html)
- [AF_ALG Socket Interface](https://www.kernel.org/doc/html/latest/crypto/userspace-if.html)
- [sendmsg() man page](https://man7.org/linux/man-pages/man2/sendmsg.2.html)


Changes Made                                                                                                                                                                                                                                                              
                                                                                                                                                                                                                                                                            
  1. Socket Communication (06_P4/P4.2_AES_in_CSU/src/aes_csu.c)                                                                                                                                                                                                             
                                                                                                                                                                                                                                                                            
  Implemented complete socket-based communication with the CSU:                                                                                                                                                                                                             
                                                                                                                                                                                                                                                                            
  Socket Creation:                                                                                                                                                                                                                                                          
                                                                                                                                                                                                                                                                            
  sd = socket(AF_ALG, SOCK_SEQPACKET, 0);                                                                                                                                                                                                                                   
                                                                                                                                                                                                                                                                            
  Algorithm Configuration:                                                                                                                                                                                                                                                  
                                                                                                                                                                                                                                                                            
  struct sockaddr_alg sa = {                                                                                                                                                                                                                                                
      .salg_family = AF_ALG,                                                                                                                                                                                                                                                
      .salg_type   = "skcipher",    // Symmetric key cipher                                                                                                                                                                                                                 
      .salg_name   = "cbc(aes)"      // AES in CBC mode                                                                                                                                                                                                                     
  };                                                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                            
  Bind Socket to Algorithm:                                                                                                                                                                                                                                                 
                                                                                                                                                                                                                                                                            
  ret = bind(sd, (struct sockaddr *) &sa, sizeof(sa));                                                                                                                                                                                                                      
                                                                                                                                                                                                                                                                            
  Set Encryption Key:                                                                                                                                                                                                                                                       
                                                                                                                                                                                                                                                                            
  ret = setsockopt(sd, SOL_ALG, ALG_SET_KEY, key, AES_KEY_LENGTH);                                                                                                                                                                                                          
                                                                                                                                                                                                                                                                            
  Send Data for Encryption:                                                                                                                                                                                                                                                 
                                                                                                                                                                                                                                                                            
  ret = sendmsg(fd, &msg, 0);                                                                                                                                                                                                                                               
                                                                                                                                                                                                                                                                            
  2. Main Program (main.c)                                                                                                                                                                                                                                                  
                                                                                                                                                                                                                                                                            
  Added timing measurements:                                                                                                                                                                                                                                                
  clock_gettime(CLOCK_REALTIME, &time_start);                                                                                                                                                                                                                               
  AES_CSU_encrypt_buffer(key, iv, enc_a, text_length);                                                                                                                                                                                                                      
  clock_gettime(CLOCK_REALTIME, &time_stop);                                                                                                                                                                                                                                
                                                                                                                                                                                                                                                                            
  Documentation Created                                                                                                                                                                                                                                                     
                                                                                                                                                                                                                                                                            
  Created P4.2_Explanation.md with comprehensive coverage:                                                                                                                                                                                                                  
                                                                                                                                                                                                                                                                            
  Key Topics:                                                                                                                                                                                                                                                               
                                                                                                                                                                                                                                                                            
  1. Configuration Security Unit (CSU)                                                                                                                                                                                                                                      
    - Secure Processor Block (triple-redundant CPU)                                                                                                                                                                                                                         
    - Crypto Interface Block (AES, SHA, RSA hardware)                                                                                                                                                                                                                       
    - Protected eFUSE key storage                                                                                                                                                                                                                                           
    - Secure boot capabilities                                                                                                                                                                                                                                              
  2. Socket Communication                                                                                                                                                                                                                                                   
    - Why sockets instead of direct access (security!)                                                                                                                                                                                                                      
    - AF_ALG socket family for cryptographic operations                                                                                                                                                                                                                     
    - Complete workflow diagram                                                                                                                                                                                                                                             
  3. Step-by-Step Implementation                                                                                                                                                                                                                                            
    - 9 detailed steps from socket creation to cleanup                                                                                                                                                                                                                      
    - Each function call explained with parameters                                                                                                                                                                                                                          
    - What happens in kernel and hardware                                                                                                                                                                                                                                   
  4. Message Structure                                                                                                                                                                                                                                                      
    - Control message headers (operation, IV)                                                                                                                                                                                                                               
    - Data buffers                                                                                                                                                                                                                                                          
    - Complete message flow diagram                                                                                                                                                                                                                                         
  5. Code Implementation Breakdown                                                                                                                                                                                                                                          
    - socket() - Create AF_ALG socket                                                                                                                                                                                                                                       
    - bind() - Bind to AES-CBC algorithm                                                                                                                                                                                                                                    
    - setsockopt() - Set encryption key                                                                                                                                                                                                                                     
    - accept() - Get data channel                                                                                                                                                                                                                                           
    - sendmsg() - Send data with headers                                                                                                                                                                                                                                    
    - read() - Receive result                                                                                                                                                                                                                                               
  6. CSU vs FPGA vs Software                                                                                                                                                                                                                                                
    - Performance comparison                                                                                                                                                                                                                                                
    - Security comparison                                                                                                                                                                                                                                                   
    - When to use each                                                                                                                                                                                                                                                      
  7. Security Features                                                                                                                                                                                                                                                      
    - Protected key storage (eFUSE)                                                                                                                                                                                                                                         
    - Secure boot capabilities                                                                                                                                                                                                                                              
    - Memory isolation                                                                                                                                                                                                                                                      
    - Tamper resistance                                                                                                                                                                                                                                                     
                                                                                                                                                                                                                                                                            
  Key Concepts Explained                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                            
  1. Why Sockets?                                                                                                                                                                                                                                                           
                                                                                                                                                                                                                                                                            
  CSU registers are not documented for security. The OS provides controlled access through the kernel crypto API using sockets.                                                                                                                                             
                                                                                                                                                                                                                                                                            
  2. AF_ALG Socket Family                                                                                                                                                                                                                                                   
                                                                                                                                                                                                                                                                            
  Special socket type for cryptographic operations:                                                                                                                                                                                                                         
  - AF_INET: Network (TCP/IP)                                                                                                                                                                                                                                               
  - AF_UNIX: Local IPC                                                                                                                                                                                                                                                      
  - AF_ALG: Cryptographic algorithms                                                                                                                                                                                                                                        
                                                                                                                                                                                                                                                                            
  3. Complete Message Structure                                                                                                                                                                                                                                             
                                                                                                                                                                                                                                                                            
  ┌─────────────────┐                                                                                                                                                                                                                                                       
  │  msghdr         │                                                                                                                                                                                                                                                       
  ├─────────────────┤                                                                                                                                                                                                                                                       
  │ Control Headers │ → Operation (Enc/Dec)                                                                                                                                                                                                                                 
  │                 │ → IV (16 bytes)                                                                                                                                                                                                                                       
  ├─────────────────┤                                                                                                                                                                                                                                                       
  │  Data Buffer    │ → Plaintext/Ciphertext                                                                                                                                                                                                                                
  └─────────────────┘                                                                                                                                                                                                                                                       
                                                                                                                                                                                                                                                                            
  4. CSU Security Advantages                                                                                                                                                                                                                                                
                                                                                                                                                                                                                                                                            
  | Feature           | FPGA                | CSU               |                                                                                                                                                                                                           
  |-------------------|---------------------|-------------------|                                                                                                                                                                                                           
  | Speed             | Very Fast           | Fast              |                                                                                                                                                                                                           
  | Key Storage       | Registers (visible) | eFUSE (protected) |                                                                                                                                                                                                           
  | Isolation         | None                | Full isolation    |                                                                                                                                                                                                           
  | Secure Boot       | No                  | Yes               |                                                                                                                                                                                                           
  | Tamper Resistance | No                  | Yes               |                                                                                                                                                                                                           
                                                                                                                                                                                                                                                                            
  Trade-off: CSU is slightly slower than FPGA due to socket overhead, but provides much better security.                                                                                                                                                                    
                                                                                                                                                                                                                                                                            
  5. eFUSE Key Storage                                                                                                                                                                                                                                                      
                                                                                                                                                                                                                                                                            
  - One-time programmable memory                                                                                                                                                                                                                                            
  - Limited write cycles (~10 times)                                                                                                                                                                                                                                        
  - Cannot be read back even by software                                                                                                                                                                                                                                    
  - Physically protected against tampering                                                                                                                                                                                                                                  
  - Perfect for production device keys                                                                                                                                                                                                                                      
                                                                                                                                                                                                                                                                            
  Building and Running                                                                                                                                                                                                                                                      
                                                                                                                                                                                                                                                                            
  # Build                                                                                                                                                                                                                                                                   
  cd 06_P4/P4.2_AES_in_CSU                                                                                                                                                                                                                                                  
  make                                                                                                                                                                                                                                                                      
  make install                                                                                                                                                                                                                                                              
                                                                                                                                                                                                                                                                            
  # Run (NO sudo needed!)                                                                                                                                                                                                                                                   
  ssh ese@10.0.0.1                                                                                                                                                                                                                                                          
  ./csu.elf                                                                                                                                                                                                                                                                 
                                                                                                                                                                                                                                                                            
  Important: Unlike FPGA (P4.1), CSU doesn't require sudo because:                                                                                                                                                                                                          
  - Socket API doesn't need root privileges                                                                                                                                                                                                                                 
  - Kernel handles all permissions                                                                                                                                                                                                                                          
  - More secure design                                                                                                                                                                                                                                                      
                                                                                                                                                                                                                                                                            
  Performance Expectations                                                                                                                                                                                                                                                  
                                                                                                                                                                                                                                                                            
  - Software (P3): ~1-10 ms                                                                                                                                                                                                                                                 
  - FPGA (P4.1): ~0.01-0.1 ms (fastest)                                                                                                                                                                                                                                     
  - CSU (P4.2): ~0.1-1 ms (middle ground)                                                                                                                                                                                                                                   
                                                                                                                                                                                                                                                                            
  Why CSU is slower than FPGA:                                                                                                                                                                                                                                              
  1. Socket creation overhead                                                                                                                                                                                                                                               
  2. Kernel message passing                                                                                                                                                                                                                                                 
  3. Security validation                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                            
  Why CSU is still valuable:                                                                                                                                                                                                                                                
  1. Protected key storage                                                                                                                                                                                                                                                  
  2. Secure boot capability                                                                                                                                                                                                                                                 
  3. Isolated execution                                                                                                                                                                                                                                                     
  4. Tamper resistance                                                                                                                                                                                                                                                      
  5. Production-ready security                                                                                                                                                                                                                                              
                                                                                                                                                                                                                                                                            
  All three labs complete! You now have:                                                                                                                                                                                                                                    
  - P3: Software AES (flexible, slow, no security)                                                                                                                                                                                                                          
  - P4.1: FPGA AES (very fast, no security)                                                                                                                                                                                                                                 
  - P4.2: CSU AES (fast + secure, production-ready)  